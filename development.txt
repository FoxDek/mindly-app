
Ход разработки приложения Mindly

Описание проекта: Mindly - игра-викторина, в которой пользователи должны отвечать на заданный вопрос самыми популярными ответами.
Пример: Что можно найти в школьном пенале? - Ответы: карандаш, линейка, ластик и т.п.

Механики:
- Доступ к уровням даётся по звёздам. Одна звезда - один пройденный подуровень. 
- Уровни могут быть двух типов:
  - просто вопрос или наводка ("Это очень часто теряют" / "Какие эмоции ты знаешь?")
  - ассоциации по изображению (фотография пикника - нужно назвать все ассоциации (например, корзинка, плед, природа и т.п.))
- Процесс игры:
  - правильный ответ открывает список слов и показывает, что слово открыто (+анимация открытия)
  - неправильный ответ через анимацию показывает, что неправильно
  - 
- Логика подсказок:
  - есть стартовый баланс
  - есть 3 типа подсказок: открыть букву; убрать лишние буквы для составления; открыть слово
  - обязательное предупреждение перед покупкой
  - В случае Х неправильных ответов будет всплывать предложение воспользоваться подсказкой
- Настройки:
  - отключить предупреждение перед покупкой подсказки
  - отключить предложение воспользоваться подсказкой в случае ряда неправильных ответов
 

Структура проекта:
1. Основной экран (Levels) - уровни, а также доступ к доп. экранам 
2. Доп. экраны
  - настройки
  - магазин (Store)
  - темы (Themes)
3. Динамический экран уровня
4. Динамический экран подуровня
5. Динамический экран слова (с подсказками)
Технические экраны:
- Splash-screen


Разработка началась 20.10.2025
За это время:
1) Разработана концепция и дизайн приложения Mindly на основе приложения 94%
2) Реализованы экраны: levels, [level], [levelPart]
3) Разработан датасет вопросов, дефолтные данные пользователя, а также функции для их изменения.
4) Подключена логика ввода, нормализация вводных данных, а также сравнение и внесение правильных ответов в базу.
5) Со стороны UI: создан индикатор прогресса уровня; вертикальный/горизонтальный скролл на подуровне; смещение к новому правильному ответу;




Изменения:
06.11
1) Пробую reanimated - добавлена анимация переворота. Но, по сути, всё навайбкодил, т.к. без понятия, как сделать анимацию только новых блоков.
Анимация срабатывает, однако возникла проблема: после переворота текст зашакален, размытый и пиксельный. Поэтому нужно как-то исправить.

08.11
1) Разобрался с проблемой размытого текста. Это баг React Native, 3D-трансформация провоцирует "аппаратный слой" (GPU compositing) и текст отображается как растр.
Решение заключается в замене rotateY: '180deg' на scaleX: -1
2) Сделал обработку ответа, если уже отгадан. Добавлена доп. анимация shake, которая срабатывает, если обращаемся к угаданному ответу. Реализовано через shakeRegistry файл, который хранит в памяти id всех ответов.

14.11
1) Разобрался в создании универсальной анимации и регистре. С помощью регистра (промежуточного звена) накидываю анимацию на любой элемент и активирую в любой части приложения.
Теперь после неправильного ответа происходит shake текстового поля.
2) Исправлены ошибки с типами, ранними вызовами хука (перед возвратом null) и пр.
3) Решил подключить добавление звёзд после пройденного уровня. Однако содержать количество звёзд как обычный счётчик может привести к потенциальным багам. Вижу 2 варианта:
  1. Брать данные пользователя (прогресс по уровням) и из каждого подуровня вытаскивать флаг isCompleted. Считать пройденные и выдавать счётчик. Вариант кажется менее производительным.
  2. Если у нас закрывается последнее слово, то увеличиваем счётчик звёзд. Далее отключаем поле ввода для уровня, поэтому получение звезды снова не станет возможно. Но можно прописать условие, чтобы добавлялось только в случае закрытия последнего слова.
  => выбрал первый вариант, т.к. он больше годится для чистой архитектуры.
4) Создал функцию getUserStars для получения количества звёзд и переделал все части приложения, которые обращаются к данным звёзд.
5) Далее хочу менять флаг isCompleted в данных пользователя, если пройден под/уровень. Вижу такую логику: каждый подуровень может содержать только определённые слова => длина его массива в итоге не/будет равна массиву загаданных слов. Из этого состояния мы можем вычислять isCompleted. По умолчанию флаг будет false, но мы будем проверять и обновлять состояние, если ответили правильно.
 - то же самое пришлось делать для всего уровня, но проверял пройденные подуровни.
 логика реализована, осталось преодолеть проблему с предвызовом сравнения данных прогресса и уровней. Пока что проверка происходит раньше установки (вместе с ней), поэтому приложение считает, что уровень всё ещё не пройден. Отталкиваться нужно от локального состояния.

 21.11
 1) Решил проблему с обновлением состояния завершённости подуровня (суть: я сверял данные уровня со старым стейтом, поэтому логика ломалась. Нужно были просто сверять новый локальный стейт. Также у нас происходит 2 обновления прогресса, а второй также ссылалось на старые данные, поэтому стал передавать в функцию локальный прогресс).
 Также убрал из данных пользователя поле "completed" для всего уровня. Это поле не используется, а также может привести к потенциальным багам. Для понимания, пройден ли уровень, будем использовать перебор всех подуровней (не вызовет проблем с оптимизацией).
 2) Берусь за подсказки. Создал обычный роут для работы со словом. Фиксирую изменения через git
 COMMIT



Список задач:
- необходимо подключить Convex-базу для хранения данных уровней, чтобы облегчить обновление
  Для подключения нужно:
  - создать бд в Convex
  - Создать типы внутри проекта
  - прописать мутации и запросы
  - использовать это всё (запрашивать один раз / брать уровни, которые подгрузились до этого)
  - поместить в хук
