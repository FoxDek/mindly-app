
Ход разработки приложения Mindly

Описание проекта: Mindly - игра-викторина, в которой пользователи должны отвечать на заданный вопрос самыми популярными ответами.
Пример: Что можно найти в школьном пенале? - Ответы: карандаш, линейка, ластик и т.п.

Механики:
- Доступ к уровням даётся по звёздам. Одна звезда - один пройденный подуровень. 
- Уровни могут быть двух типов:
  - просто вопрос или наводка ("Это очень часто теряют" / "Какие эмоции ты знаешь?")
  - ассоциации по изображению (фотография пикника - нужно назвать все ассоциации (например, корзинка, плед, природа и т.п.))
- Процесс игры:
  - правильный ответ открывает список слов и показывает, что слово открыто (+анимация открытия)
  - неправильный ответ через анимацию показывает, что неправильно
  - 
- Логика подсказок:
  - есть стартовый баланс
  - есть 3 типа подсказок: открыть букву; убрать лишние буквы для составления; открыть слово
  - обязательное предупреждение перед покупкой
  - В случае Х неправильных ответов будет всплывать предложение воспользоваться подсказкой
- Настройки:
  - отключить предупреждение перед покупкой подсказки
  - отключить предложение воспользоваться подсказкой в случае ряда неправильных ответов
 

Структура проекта:
1. Основной экран (Levels) - уровни, а также доступ к доп. экранам 
2. Доп. экраны
  - настройки
  - магазин (Store)
  - темы (Themes)
3. Динамический экран уровня
4. Динамический экран подуровня
5. Динамический экран слова (с подсказками)
Технические экраны:
- Splash-screen


Разработка началась 20.10.2025
За это время:
1) Разработана концепция и дизайн приложения Mindly на основе приложения 94%
2) Реализованы экраны: levels, [level], [levelPart]
3) Разработан датасет вопросов, дефолтные данные пользователя, а также функции для их изменения.
4) Подключена логика ввода, нормализация вводных данных, а также сравнение и внесение правильных ответов в базу.
5) Со стороны UI: создан индикатор прогресса уровня; вертикальный/горизонтальный скролл на подуровне; смещение к новому правильному ответу;




Изменения:
06.11
1) Пробую reanimated - добавлена анимация переворота. Но, по сути, всё навайбкодил, т.к. без понятия, как сделать анимацию только новых блоков.
Анимация срабатывает, однако возникла проблема: после переворота текст зашакален, размытый и пиксельный. Поэтому нужно как-то исправить.

08.11
1) Разобрался с проблемой размытого текста. Это баг React Native, 3D-трансформация провоцирует "аппаратный слой" (GPU compositing) и текст отображается как растр.
Решение заключается в замене rotateY: '180deg' на scaleX: -1
2) Сделал обработку ответа, если уже отгадан. Добавлена доп. анимация shake, которая срабатывает, если обращаемся к угаданному ответу. Реализовано через shakeRegistry файл, который хранит в памяти id всех ответов.

14.11
1) Разобрался в создании универсальной анимации и регистре. С помощью регистра (промежуточного звена) накидываю анимацию на любой элемент и активирую в любой части приложения.
Теперь после неправильного ответа происходит shake текстового поля.
2) Исправлены ошибки с типами, ранними вызовами хука (перед возвратом null) и пр.
3) Решил подключить добавление звёзд после пройденного уровня. Однако содержать количество звёзд как обычный счётчик может привести к потенциальным багам. Вижу 2 варианта:
  1. Брать данные пользователя (прогресс по уровням) и из каждого подуровня вытаскивать флаг isCompleted. Считать пройденные и выдавать счётчик. Вариант кажется менее производительным.
  2. Если у нас закрывается последнее слово, то увеличиваем счётчик звёзд. Далее отключаем поле ввода для уровня, поэтому получение звезды снова не станет возможно. Но можно прописать условие, чтобы добавлялось только в случае закрытия последнего слова.
  => выбрал первый вариант, т.к. он больше годится для чистой архитектуры.
4) Создал функцию getUserStars для получения количества звёзд и переделал все части приложения, которые обращаются к данным звёзд.
5) Далее хочу менять флаг isCompleted в данных пользователя, если пройден под/уровень. Вижу такую логику: каждый подуровень может содержать только определённые слова => длина его массива в итоге не/будет равна массиву загаданных слов. Из этого состояния мы можем вычислять isCompleted. По умолчанию флаг будет false, но мы будем проверять и обновлять состояние, если ответили правильно.
 - то же самое пришлось делать для всего уровня, но проверял пройденные подуровни.
 логика реализована, осталось преодолеть проблему с предвызовом сравнения данных прогресса и уровней. Пока что проверка происходит раньше установки (вместе с ней), поэтому приложение считает, что уровень всё ещё не пройден. Отталкиваться нужно от локального состояния.

 21.11
 1) Решил проблему с обновлением состояния завершённости подуровня (суть: я сверял данные уровня со старым стейтом, поэтому логика ломалась. Нужно были просто сверять новый локальный стейт. Также у нас происходит 2 обновления прогресса, а второй также ссылалось на старые данные, поэтому стал передавать в функцию локальный прогресс).
 Также убрал из данных пользователя поле "completed" для всего уровня. Это поле не используется, а также может привести к потенциальным багам. Для понимания, пройден ли уровень, будем использовать перебор всех подуровней (не вызовет проблем с оптимизацией).
 2) Берусь за подсказки. Создал обычный роут для работы со словом. Фиксирую изменения через git
 COMMIT

24.11
1) Реализую подсказки
Логика: Перед переходом на страницу подсказок будет появляться модалка для оплаты доступа к этой странице.
Логично будет подключить доп. поле "hints" к прогрессу для каждого слова. Предполагаю, что это будет объект с полями: isOpened, usedHints (тоже объект с полями: lettersOpened и extraLettersRemoved. Думаю, что не нужно поле для открытия всего слова).
Для подсказок лучше всего будет создать объект с ценами и названиями
- создан роут app/hints/index.tsx; Выход на роут происходит через модальное окно (тоже создал универсальный confirmation-modal блок).

05.12
0) реализую страницу по блокам. План: 
  1. Скрытое слово - генерация скрытых букв с постепенным открытием (сложности: мб анимация, учёт пробела, открытие определённой буквы)
  2. клавиатура с доступными буквами (буквы слова перемещать в массив, дозаполнять его, учитывая длину и вперемешку рендерить). Для перемешивания используем метод Фишера — Йетса.
  3. Подсказки - логика простая, но нужно обновить датасет юзера с usedHints
1) Отрендерил скрытое слово: одна буквы открыта по умолч., остальные скрыты
2) Разработал функции для получения массива случайных русских букв, а также для перемешивания массива (далее эти функции станут неактуальны)
3) Отрендерил клавиатуру с буквами (однако возникла проблема с UI: сложно было встроить кнопку удаления рядом без багов => кнопка удаления теперь под клавиатурой)

08.12
1) Обновил схему уровней, внёс extraLetters в объект каждого ответа (оптимальное решение)
2) Добавил к каждому уровню в прогрессе поле usedHints, однако возникла проблема с получением этих данных (и решилась):
  - проблема была в том, что получить partProgress напрямую в корневом пути '/hints' нельзя (как и level с levelPart). Нельзя, т.к. в параметрах роута нет данных о том, с какого уровня мы перешли (я не хотел создавать глубокую вложенность по типу 'level/levelPart/hints').
  Для решения пришлось прокидывать level и levelPart из блока, который вызывает модалку, через модалку и только потом получать в 'hints'.
  Далее я просто получал данные всех уровней, из которых вытягивал прогресс подуровня, а затем и нужный usedHints у слова.
3) Реализовал функции addLetter и deleteLetter. В массиве currentWord находим первый null и заменяем его на букву. Либо наоборот удаляем первую вставленную букву с конца (условно обходя заранее открытые)
- остаётся только помечать выбранные буквы на клавиатуре, но это легко: записываем индекс всех выбранных букв.
4) Реализовал выбор букв клавиатуры
- нужно доб. условие, чтобы нельзя было нажать на одну и ту же клавишу дважды

09.12
Для завершения экрана нужно:
  - добавить проверку, что слово отгадано
  - добавить анимацию, если слово не отгадано (шейк)
  - стилизовать свободные ячейки
1) Закрыл возможность вставить одну и ту же букву дважды (можно подумать над доп. условием: если длина предполагаемого слова (массива) равно загадонному слову, то ничего не вставлять сразу, т.е. ещё до внутр. проверки функции)
2) Добавил проверку, является ли собранное слово ответом. Подключил анимацию в противном случае (помогала нейросеть, т.к. муть полная)
3) Внутри роутинга на страницу подсказок заменил push на replace. Это позволило во время возврата на пред. страницу обходить открытую модалку.

11.12
Действия в случае отгаданного слова: перебрасываем назад -> открываем слово и совершаем стандартные действия по открытию
1) Функцию handleSendValue прокачал, теперь она работает и с внешним значением 
Столкнулся с проблемой: мне нужно запускать функцию handleSendValue после того, как я угадал слово. Есть 2 варианта:
  - открыть его заранее, показать анимацию на hints (чтобы юзер понял, что он угадал), а затем редирект назад (мне не особо нравится вариант)
  - редирект назад и открытие слово с помощью handleSendValue – тогда анимация проиграется полностью.
  Я выбрал второй способ, но возникли трудности: сложно редиректить и запускать функцию. Попробовал передавать параметры в router, а затем через UEF отслеживать изменение этого параметра. Однако переход с back не передавал параметры адекватно, поэтому я использовал replace прямо на подуровень и всё заработало. Слово стало открываться с анимацией.
  И всё же осталась проблема – в навигационном стеке сохраняется 2 levelPart. Если модалку мы закрываем, то levelPart попадает в стэк дважды. Поэтому после replace нажатие "назад" открывает не меню уровня, а эту же страницу levelPart.
  Предполагаю, что стоит перенести hints внутрь levelPart. Плевать на глубокую вложенность, если всё будет работать более корректно и просто. Просто сейчас это кажется каким-то нагромаждением логик.
  Перед изменениями сделаю коммит, чтобы вернуться, если ничего толком не поменяется.
'COMMIT'
  
12.12
Решил переписать страницу hints, чтобы она стала частью маршрута level/levelPart/hints. 
1) Теперь hints следует в роуте после levelPart. Странно, но работа с параметрами почти не изменилась. Всё приходится также передавать странным способом.
2) Проблема с активацией handleSendValue осталась такой же, однако была легко решена с помощью глоабльного стейта (не лучший вариант, но простой и рабочий)
3) Создал хук для работы с балансом пользователя. Подключил обновление баланса после покупки подсказки. Столкнулся с проблемой: нужно сохранять данные о покупке подсказки, чтобы не платить дважды за открытие. Также у нас могут быть открыты подсказки для каждого слова. А usedHints лежит как глобальный объект, который содержит данные "для всех". Т.е. буквы будут открываться у каждого слова при покупке.
Нужно разделять эти объекты для каждого слова.
4) Изменил датасет пользователя для хранения объекта подсказок у каждого слова. При этом объект генерится динамически, чтобы не усложнять дерево данных с самого начала.
Вынес типы в отдельную папку, чтобы было удобнее работать и обновлять повсеместно.
(однако сломалась страница подсказок, слово не передаётся)

13.12
1) Изменил логику перехода к Hints:
  - нажатие по блоку слова запускает проверку, есть ли индекс слова в массиве hintsOpened данных пользователя;
  - если есть, то сразу открывает Hints;
  - если нет, то открывает модалку, которая изменяет баланс и заменяет заполнитель usedHints на полноценный объект подсказок;
  пришлось дополнительно исправлять ошибки с типами в дочерних компонентах: 
2) Создал кнопки подсказок и начал прописывать их логику. Для каждой создал функцию обновления баланса и взялся за открытие буквы.
  - буквы удаётся добавлять, но они не отображаются, на их место можно вставить буквы из клавиатуры, но убрать не получится. Также сейчас не учитывается, что слово можно так открыть полностью. Т.о. необходимо:
    1) обновить логику поведения, если занято всё слово. Т.е. активировать проверку по заполнению, а не по открытию буквы.
    2) Добиться отображения буквы после её открытия
    3) сделать так, чтобы из клавиатуры пропадали открытые буквы

15.12
1) Исправил ошибку перезаписи данных. Сначала обновление массива с индексами открытых подсказок у слов происходило на странице подсказок. Однако я убрал в модалку, где два обновления шли друг за другом, что вызывало перезапись. В итоге обновил саму функцию createUsedHints, чтобы она сразу с созданием объекта usedHints обновляла и этот массив.
2) Решаю проблему отображения символов после открытия. Ситуация: открытие буквы с помощью подсказки странно влияет на UI. Вместо стилей незанятой ячейки применяются стили занятой, но вот содержимое сразу не появляется. Для обновления UI приходится перезайти на страницу.
- решил просто: стал обновлять стейт с действующим словом сразу после использования Подсказки
3) Сделал все буквы в upperCase, также проверку сделал рабочей, т.к. до этого из-за разности кегля не принимались слова
4) Почти реализовал функцию удаления лишних букв. Нажатия по клавиатуре доступны даже после скрытия экстра-символов. По сути работает

18.12
1) Отключил кнопки клавиатуры, которые скрыты (до этого можно было использовать). Также обновил стили, чтобы их вообще не было видно. Упростил для понимания условие скрытия.
2) Внутри функции для составления новой клавиатуры  (после удаления лишних символов) создал новую функцию removeLettersByIndices, которая удаляет из слова все открытые буквы. Всё работает отлично, однако после удаления лишних и очередного открытия буквы почему-то клавиатура возвращается в изначальное состояние. Скорее всего стейт данных переписывается обратно.
2.1) Работа функции deleteExtraLetters (удалить лишние из клавиатуры) налажена, всё работает отлично.
'COMMIT'

19.12
1) Сделал обработчик для полного открытия слова. Просто в currentWord устанавливаю само слово, а уже дальше обновление слова ловит useEffect (его условие подкорректировал, чтобы срабатывало с опорой на длину currentWord без учитывания null)
2) Обновил UI, добавил лейблы с ценой на кнопки подсказок
3) В Hints сделал адаптивный текст, чтобы переносился и менял размер в зависимости от размеров экрана (брейкпоинт)
4) Исправил все повторные списывания после покупки. Также модалка не переведёт на подсказки, если нет денег

22.12
1) Сделал адаптивный размер ячеек слова и клавиатуры в зависимости от размеров экрана
2) Изменил UI для лучшего пользовательского опыта
3) Отключил работу поля ввода, если слово отгадано
4) Добавил модалку после того, как пройден подуровень (модалка после прохождения уровня не работает, нужно вынести проверку в отдельную функцию)
5) Изменил датасет экономики проекта, реализовал функции для начисления баланса, подключил их к ключевым действиям

25.12
1) Исправил открытие буквы даже если нет денег
2) Исправил ошибку после ввода в пустом инпуте

26.12
1) Скорректировал условия проверки на пройденный уровень и подуровень.
2) Исправлена проблема с отображением модалок после прохождения. Теперь после модалки с пройденным подуровнем появляется модалка с пройденным уровнем.
3) Изменения баланса также скорректированы, однако решение по структуре может быть не лучшим: начисление было вынесено в файл модалки, где проверяется условие для открытия модалки с пройденным уровнем. Сделал так, потому что функции переписывали друг друга. Можно было добавить условие и параметры в сами функции начисления, но тоже не лучший вариант.
4) Работаю над уровнем с картинкой:
  4.1 - создал бакет в Yandex Storage, загрузил изображения
  4.2 - Сделал условный рендеринг вопроса и изображения в levelPart
  4.3 - изменил превью на уровень Level, чтобы на фоне кнопки подуровня отображалось изображение

02.01
Дорабатываю проект в новом году
1) Решил отправить изображение в уровне на фон. Вместо рендера внутри QuizArea я разместил его как родителя хэдера и всего содержимого (вопрос, ответы)
2) Подключил react-native-image-viewing, чтобы открывать изображение для просмотра. Для открытия нужно было создать зону нажатия; самый оптимальный вариант - просто сделать кликабельное контейнер с вопросом (в идеале для лучшего UE нужно создать модалку с инструкцией)

09.01
Разбирался с проблемой перерисовки Image-компонентов. При удалении из стека экрана с изображением, постоянно происходит подгрузка во время очередного открытия. Сначала отображается placeholder, а только потом изображение. Учитывая, что дело не в интернете (т.к. изобр. хранится в кэше), необходимо как-то не размонтировать экраны / подгружать изобр. заранее.
  Для исправления попробовал создать layout на уровне [level], чтобы делать prefetch изображения. Однако эффект не особо заметен.
- пока что во время загрузки будет использоваться ActivityIndicator

10.01
- Создал оверлей, который появляется при скролле, когда есть изображение. Сделано для удобства просмотра ответов.
'COMMIT'




Проблемы:




Не забыть:
- модалка с инструкцией к уровню с изображением
- модалка с объяснением, как открыть изображение на весь экран
- 

Список задач:
- необходимо подключить Convex-базу для хранения данных уровней, чтобы облегчить обновление
  Для подключения нужно:
  - создать бд в Convex
  - Создать типы внутри проекта
  - прописать мутации и запросы
  - использовать это всё (запрашивать один раз / брать уровни, которые подгрузились до этого)
  - поместить в хук
